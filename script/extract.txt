s -> save_nSelectors = nSelectors
s -> save_groupPos = 0
s -> save_gMinlen = 0
s -> save_gSel = 0
gBase = s -> save_gBase
gSel = s -> save_gSel
groupNo = s -> save_groupNo
gLimit = s -> save_gLimit
s -> save_gBase = NULL
s -> storedCombinedCRC = ( s -> storedCombinedCRC << 8 ) | ( ( UInt32 ) uc )
s -> save_zvec = zvec
s -> save_j = j
i = s -> save_i
s -> save_nextSym = 0
EOB = s -> save_EOB
s -> save_t = t
zj = s -> save_zj
s -> save_nblockMAX = nblockMAX
t = s -> save_t
s -> save_curr = 0
nSelectors = s -> save_nSelectors
s -> storedCombinedCRC = ( s -> storedCombinedCRC << 8 ) | ( ( UInt32 ) uc )
zn = s -> save_zn
nGroups = s -> save_nGroups
s -> save_groupNo = groupNo
s -> save_zn = 0
s -> storedCombinedCRC = 0
zt = s -> save_zt
s -> save_gLimit = gLimit
curr = s -> save_curr
nblock = s -> save_nblock
j = s -> save_j
s -> save_zt = 0
s -> save_groupNo = 0
s -> save_EOB = 0
alphaSize = s -> save_alphaSize
s -> save_gPerm = gPerm
s -> save_nblock = 0
s -> save_i = 0
bz_stream * strm = s -> strm ;
groupPos = s -> save_groupPos
s -> save_zj = 0
s -> save_es = es
s -> save_gMinlen = gMinlen
nblockMAX = s -> save_nblockMAX
s -> storedCombinedCRC = ( s -> storedCombinedCRC << 8 ) | ( ( UInt32 ) uc )
s -> save_i = i
s -> state = BZ_X_IDLE
s -> save_curr = curr
s -> save_zj = zj
s -> save_zn = zn
s -> save_nblockMAX = 0
s -> save_EOB = EOB
s -> save_j = 0
s -> save_N = 0
zvec = s -> save_zvec
s -> save_gLimit = NULL
es = s -> save_es
gPerm = s -> save_gPerm
s -> save_t = 0
s -> save_es = 0
s -> save_zvec = 0
s -> storedCombinedCRC = ( s -> storedCombinedCRC << 8 ) | ( ( UInt32 ) uc )
s -> save_N = N
N = s -> save_N
s -> save_alphaSize = 0
s -> save_nGroups = 0
s -> save_nSelectors = 0
s -> save_gBase = gBase
s -> save_nblock = nblock
s -> save_alphaSize = alphaSize
s -> save_groupPos = groupPos
s -> save_gPerm = NULL
gMinlen = s -> save_gMinlen
s -> save_nGroups = nGroups
s -> save_gSel = gSel
s -> save_zt = zt
nextSym = s -> save_nextSym
s -> save_nextSym = nextSym
retVal = BZ_OK
s -> k0 ^= BZ_RAND_MASK
s -> nblock_used = 0
s -> tPos = s -> tt [ s -> origPtr ] >> 8
s -> tt [ s -> cftab [ uc ] ] |= ( i << 8 )
uc = ( UChar ) ( s -> tt [ i ] & 0xff )
i = 0 ;
s -> k0 ^= BZ_RAND_MASK
s -> nblock_used = 0
s -> tPos = s -> origPtr
Int32 tmp = GET_LL ( j ) ;
j = tmp
i = j
j = GET_LL ( i )
i = s -> origPtr
uc = ( UChar ) ( s -> ll16 [ i ] )
i = 0 ;
s -> cftabCopy [ i ] = s -> cftab [ i ]
i = 0 ;
s -> state = BZ_X_OUTPUT
s -> state_out_ch = 0
s -> state_out_len = 0
i = 0 ;
s -> cftab [ i ] += s -> cftab [ i - 1 ]
i = 1 ;
s -> cftab [ i ] = s -> unzftab [ i - 1 ]
i = 1 ;
s -> cftab [ 0 ] = 0
es = - 1
s -> ll16 [ nblock ] = ( UInt16 ) ( s -> seqToUnseq [ uc ] )
s -> tt [ nblock ] = ( UInt32 ) ( s -> seqToUnseq [ uc ] )
s -> tt [ nblock ] = ( UInt32 ) uc
s -> ll16 [ nblock ] = ( UInt16 ) uc
pp = s -> mtfbase [ 0 ]
uc = s -> seqToUnseq [ s -> mtfa [ s -> mtfbase [ 0 ] ] ]
s -> mtfa [ pp ] = s -> mtfa [ pp - 1 ]
s -> unzftab [ uc ] += es
uc = s -> mtfa [ pp ]
uc = s -> mtfa [ pp + nn ]
pp = s -> mtfbase [ lno ] + off
s -> mtfa [ ( z ) ] = s -> mtfa [ ( z ) - 1 ]
s -> mtfa [ ( pp + nn ) ] = s -> mtfa [ ( pp + nn ) - 1 ]
s -> mtfa [ pp ] = uc
Int32 z = pp + nn ;
s -> mtfa [ s -> mtfbase [ lno ] ] = s -> mtfa [ s -> mtfbase [ lno - 1 ] + MTFL_SIZE - 1 ]
s -> mtfa [ s -> mtfbase [ 0 ] ] = uc
s -> mtfa [ ( z ) - 1 ] = s -> mtfa [ ( z ) - 2 ]
s -> mtfa [ kk ] = s -> mtfa [ s -> mtfbase [ ii ] + jj ]
s -> mtfa [ ( z ) - 2 ] = s -> mtfa [ ( z ) - 3 ]
nn = ( UInt32 ) ( nextSym - 1 )
s -> mtfa [ ( z ) - 3 ] = s -> mtfa [ ( z ) - 4 ]
kk = MTFA_SIZE - 1
s -> mtfbase [ ii ] = kk + 1
jj = MTFL_SIZE - 1 ;
ii = 256 / MTFL_SIZE - 1 ;
off = nn % MTFL_SIZE
lno = nn / MTFL_SIZE
nn -= 4
es = es + ( 0 + 1 ) * N
N = N * 2
es = es + ( 1 + 1 ) * N
N = 1
nblock = 0
s -> mtfbase [ ii ] = kk + 1
s -> mtfa [ kk ] = ( UChar ) ( ii * MTFL_SIZE + jj )
jj = MTFL_SIZE - 1 ;
ii = 256 / MTFL_SIZE - 1 ;
kk = MTFA_SIZE - 1
s -> unzftab [ i ] = 0
i = 0 ;
groupPos = 0
groupNo = - 1
nblockMAX = 100000 * s -> blockSize100k
EOB = s -> nInUse + 1
s -> minLens [ t ] = minLen
maxLen = s -> len [ t ] [ i ]
minLen = s -> len [ t ] [ i ]
minLen = 32
maxLen = 0
i = 0 ;
t = 0 ;
s -> len [ t ] [ i ] = curr
i = 0 ;
t = 0 ;
s -> selector [ i ] = tmp
v = s -> selectorMtf [ i ]
tmp = pos [ v ]
pos [ v ] = pos [ v - 1 ]
pos [ 0 ] = tmp
i = 0 ;
pos [ v ] = v
v = 0 ;
s -> selectorMtf [ i ] = j
j = 0
i = 0 ;
alphaSize = s -> nInUse + 2
s -> inUse [ i * 16 + j ] = True
j = 0 ;
i = 0 ;
s -> inUse [ i ] = False
i = 0 ;
s -> inUse16 [ i ] = False
s -> inUse16 [ i ] = True
i = 0 ;
s -> origPtr = ( s -> origPtr << 8 ) | ( ( Int32 ) uc )
s -> origPtr = ( s -> origPtr << 8 ) | ( ( Int32 ) uc )
s -> origPtr = ( s -> origPtr << 8 ) | ( ( Int32 ) uc )
s -> origPtr = 0
s -> storedBlockCRC = ( s -> storedBlockCRC << 8 ) | ( ( UInt32 ) uc )
s -> storedBlockCRC = ( s -> storedBlockCRC << 8 ) | ( ( UInt32 ) uc )
s -> storedBlockCRC = ( s -> storedBlockCRC << 8 ) | ( ( UInt32 ) uc )
s -> storedBlockCRC = ( s -> storedBlockCRC << 8 ) | ( ( UInt32 ) uc )
s -> storedBlockCRC = 0
s -> tt = BZALLOC ( s -> blockSize100k * 100000 * sizeof ( Int32 ) )
s -> ll4 = BZALLOC ( ( ( 1 + s -> blockSize100k * 100000 ) >> 1 ) * sizeof ( UChar ) )
s -> ll16 = BZALLOC ( s -> blockSize100k * 100000 * sizeof ( UInt16 ) )
s -> blockSize100k -= BZ_HDR_0
